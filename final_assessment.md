# Final Assessment

__Yiju Xue A59010487__

_Compiler B - Comprehensions_

_Describe how you would support comprehensions on lists with a filter (e.g. that have an "if" clause)_

---

## Starting Point

I would imagine a successful merge of the latest pull request of our group [(Comprehensions - Week 10 #81)](https://github.com/ucsd-cse231-s22/chocopy-wasm-compiler-B/pull/81) and the main branch as the starting point. As is updated in the file ```designs/comprehensions-design.md```, we can now support ___real set comprehensions___ (i.e. data generated by a set comprehension will actually be stored in a set), and the `<iterable>` we can deal with now include
`list`, `set`, or any iterable class with `next()` and `hasnext()`. 
```python
# TRUE set comprehension
s:set[int] = None
s = {<expr> for <item> in <iterable> if <if_cond>}

# FAKE list comprehension -- need print to visualize
[print(<expr>) for <item> in <iterable> if <if_cond>] 

# FAKE generator comprehension -- need print to visualize
(print(<expr>) for <item> in <iterable> if <if_cond>) 
```
To support ___real list comprehensions___, the ```list.append()``` method newly added by the list group in their [Milestone 2](https://github.com/ucsd-cse231-s22/chocopy-wasm-compiler-B/blob/a215a8d63c125b95869ace62d7eaf3f81dee556a/designs/lists-design.md) is needed for creating the returned list element by element. 

---

## Expected Behavior

The extension is intended to store the data generated by a list comprehension in a list. 
```python
l: [int] = None
l = [<expr> for <item> in <iterable> if <if_cond>]
```
Test cases below demonstrate the expected behavior of the extension:
```python
# list comprehension with a Range object as <iterable>
l: [int] = None
l = [i for i in Range().new(0,5,1) if i % 2 == 0]
print(l) # should print [0, 2, 4]
```
```python
# list comprehension with a list as <iterable>
l: [int] = None
l = [i+1 for i in [3, 6, 0, 8, 2] if i < 5]
print(l[0], l[1], l[2]) # should print 4, 1, 3
```
```python
# list comprehension with a set as <iterable>
l: [int] = None
l = [i*2 for i in {-1, 1, 3, 7, 9} if i % 3 == 0]
l.append(1)
print(l) # should print [6, 18, 1]
```
```python
# list comprehension with a list as <iterable> and ternary expression as <expr>
l: [int] = None
l = [i+1 if i % 2 == 0 else i-1 for i in [3, 6, 0, 8, 2] if i < 5]
print(l) # should print [2, 1, 1]
```
```python
# list comprehension with a set as <iterable> and ternary expression as <expr>
l: [int] = None
l = [-i if i < 0 else i for i in {-4, -1, 3, 4, 7, 9} if i < 5]
print(len(l)) # should print 4
```

---

## Changes Needed

As is stated above, the current compiler can support ___fake list comprehensions___. To support ___real list comprehensions___, changes need to be make in ```lower.ts```, function ```flattenExprToExpr```, under case ```comprehension```. 

1. We used a boolean value ```isSetComp``` to differentiate set comprehension case from list and generator comprehension cases. And we used ```resultSet``` to store the generated data. (line 603 - line 605)
```typescript
const isSetComp = e.type.tag === "set" ? true : false;
const resultSet : AST.Expr<[Type, SourceLocation]> = { a: [e.type, e.a[1]], tag: "set", values: []};
var [scinits, scstmts, scval] = flattenExprToVal(resultSet, blocks, env);
```
* Like set comprehension, I would consider add a boolean value ```isListComp``` to denote list comprehension, and use ```resultList``` to store data. Similarly, ```flattenExprToVal``` will be called to get ```lcinits```, ```lcstmts``` and ```lcval```. Below code will be added:
```typescript
const isListComp = e.type.tag === "list" ? true : false;
const resultList : AST.Expr<[Type, SourceLocation]> = { a: [e.type, e.a[1]], tag: "list", values: []};
var [lcinits, lcstmts, lcval] = flattenExprToVal(resultList, blocks, env);
```
2. In the ```switch (objTyp.tag)``` cases, in line 681 for case ```list```, 686 for case ```set```, and 690 for case ```class```, respectively, in the same function call ```pushStmtsToLastBlock``` of the three cases, the boolean value ```isSetComp``` is used to push different values for ___set comprehension___ and other comprehensions.
```typescript
pushStmtsToLastBlock(blocks, ...(isSetComp ? scstmts : []), ...objstmts, ...listmts, listLengthAssign, listIterableAssign);
```
* For the three cases, I'd modify the ```pushStmtsToLastBlock``` by adding ```isListComp``` and ```lcstmts```:
```typescript
pushStmtsToLastBlock(blocks, ...(isSetComp ? scstmts : (isListComp ? lcstmts : [])), ...objstmts, ...listmts, listLengthAssign, listIterableAssign);
```
3. In the ```if``` branch of the ```if (isSetIterable)``` statement, starting from line number 755 to line number 764, while handling the first item, we used ```isSetComp``` to assign different values to ```thenStmtsSet```. 
```typescript
const firstYield = generateName("firstYield");
firstYieldVarInit = { a: e.a, name: firstYield, type: ffval.a[0], value: { a: [{ tag: "none" }, e.a[1]], tag: "none" } };
const firstYieldAssign : IR.Stmt<[Type, SourceLocation]> =  { a: e.a, tag: "assign", name: firstYield, value: ffval };
const addFirstYieldToSet : IR.Stmt<[Type, SourceLocation]> = {
    a: [{ tag: "number" }, e.a[1]],
    tag: "expr",
    expr: { a: [{ tag: "number" }, e.a[1]], tag: "call", name: "set$add", arguments: [scval, { a: e.a, tag: "id", name: firstYield }] }
};
const thenStmtsSet = isSetComp ? [firstYieldAssign, addFirstYieldToSet] : [firstYieldAssign];
```
* Similarly, for list comprehension, ```addFirstYieldToList``` is also needed, using the ```list.append()``` API provided by the list group. I'd add below code:
```typescript
const addFirstYieldToList : IR.Stmt<[Type, SourceLocation]> = {
    a: [{ tag: "number" }, e.a[1]],
    tag: "expr",
    expr: { a: [{ tag: "number" }, e.a[1]], tag: "call", name: "list$append", arguments: [lcval, { a: e.a, tag: "id", name: firstYield }] }
};
```
* And I'd modify the ```thenStmtsSet``` line to also handle ___real list comprehension___:
```typescript
const thenStmtsSet = isSetComp ? [firstYieldAssign, addFirstYieldToSet] : (isListComp ? [firstYieldAssign, addFirstYieldToList] : [firstYieldAssign]);
```
4. Betweening line number 791 an line number 800, while evaluating lhs, we used ```addToSet``` for set comprehensions. The ```addToSet``` is later used for ```thenStmts``` in line number 816.
```typescript
const [lhsinits, lhsstmts, lhsval] = flattenExprToExpr(e.lhs, blocks, env);
const nextYield = generateName("nextYield");
const nextYieldVarInit : IR.VarInit<[Type, SourceLocation]> = { a: e.a, name: nextYield, type: lhsval.a[0], value: { a: e.a, tag: "none" } };
const nextYieldAssign : IR.Stmt<[Type, SourceLocation]> =  { a: e.a, tag: "assign", name: nextYield, value: lhsval };

const addToSet : IR.Stmt<[Type, SourceLocation]> = {
a: [{ tag: "number" }, e.a[1]],
tag: "expr",
expr: { a: [{ tag: "number" }, e.a[1]], tag: "call", name: "set$add", arguments: [scval, { a: e.a, tag: "id", name: nextYield }] }
};
```
```typescript
const thenStmts = isSetComp ? [nextYieldAssign, addToSet] : [nextYieldAssign];
```
* Similarly, I'd add ```addToList``` for list comprehensions:
```typescript
const addToList : IR.Stmt<[Type, SourceLocation]> = {
a: [{ tag: "number" }, e.a[1]],
tag: "expr",
expr: { a: [{ tag: "number" }, e.a[1]], tag: "call", name: "list$append", arguments: [lcval, { a: e.a, tag: "id", name: nextYield }] }
};
```
* And also modify ```thenStmts``` to support list comprehensions:
```typescript
const thenStmts = isSetComp ? [nextYieldAssign, addToSet] : (isListComp ? [nextYieldAssign, addToList] : [nextYieldAssign]);
```
5. Lastly, in the return statement, we used ```isSetComp``` to return different value for ___set comprehension___ and other comprehensions.
```typescript
if (isListIterable) {
    return [
        [...(isSetComp ? scinits : []), ...objinits, ...liinits, listLengthVarInit, listIterableVarInit, ...cinits, ...lhsinits, hasnextVarInit, nextVarInit, nextYieldVarInit],
        [],
        toRetExpr
    ];
} else if (isSetIterable) {
    return [
        [...(isSetComp ? scinits : []), ...objinits, ...ccinits, ...cinits, ...ffinits, ...lhsinits, hasnextVarInit, nextVarInit, firstYieldVarInit, nextYieldVarInit],
        [],
        toRetExpr
    ];
} else {
    return [
        [...(isSetComp ? scinits : []), ...objinits, ...cinits, ...lhsinits, hasnextVarInit, nextVarInit, nextYieldVarInit],
        [],
        toRetExpr
    ];
}
```
* Similarly, I'd modify above code using ```isListComp``` to support ___real list comprehension___.
```typescript
if (isListIterable) {
    return [
        [...(isSetComp ? scinits : (isListComp ? lcinits : [])), ...objinits, ...liinits, listLengthVarInit, listIterableVarInit, ...cinits, ...lhsinits, hasnextVarInit, nextVarInit, nextYieldVarInit],
        [],
        toRetExpr
    ];
} else if (isSetIterable) {
    return [
        [...(isSetComp ? scinits : (isListComp ? lcinits : [])), ...objinits, ...ccinits, ...cinits, ...ffinits, ...lhsinits, hasnextVarInit, nextVarInit, firstYieldVarInit, nextYieldVarInit],
        [],
        toRetExpr
    ];
} else {
    return [
        [...(isSetComp ? scinits : (isListComp ? lcinits : [])), ...objinits, ...cinits, ...lhsinits, hasnextVarInit, nextVarInit, nextYieldVarInit],
        [],
        toRetExpr
    ];
}
```